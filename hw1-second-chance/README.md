# hw1-second-chance

[![MIT license](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/niki999922/fp-homework/blob/master/hw1-second-chance/LICENSE)


## Блок 6: Парсер-комбинаторы

Это блок самый важный в этом домашнем задании. Реализация всех упражнений из этого блока поможет понять, как устроены парсер-комбинаторы, а это важно, потому что они крайне полезны на практике. Перед решением заданий убедитесь, что вы осознали материал лекции и можете прорешать базовые упражнения по следующим ссылкам:

* [Parser Combinators: Basics](http://www.seas.upenn.edu/~cis194/spring13/hw/10-applicative.pdf)
* [Parser Combinators: Implementing simple parser](http://www.seas.upenn.edu/~cis194/spring13/hw/11-applicative2.pdf)

Основная часть упражнений оттуда всё равно является частью этого домашнего задания.

**Тесты:** в заданиях этого блока необходимо написать несколько юнит-тестов при помощи `hspec`. Property-based тесты по желанию.

### Задание 1: Copy-paste

Имеется тип простого парсер-комбинатора:

```haskell=
data Parser s a = Parser { runParser :: [s] -> Maybe (a, [s]) }
```

В отличие от парсера предложенного на практике, он может работать не только со строкой, но и с любым потоком данных. Реализуйте вручную инстансы `Functor`, `Applicative`, `Monad` и `Alternative` для этого парсера.

### Задание 2: Базовые комбинаторы

Реализуйте следующие базовые комбинаторы:

1. `ok` --- парсер никогда не падает и не поглащает инпут.
2. `eof` --- проверяет, что парсер дошёл до конца потока данных (иначе падает).
3. `satisfy` --- парсер принимает предикат на элемент потока, и возвращает элемент, поглащая его из потока, если предикат на элемент равен `True`, иначе падает.
4. `element` и `stream` --- парсят один или несколько элементов потока (как `char` и `string`).

### Задание 3: Простые парсеры

Используя существующие комбинаторы (реализовав по необходимости остальные) напишите следующие парсеры строковых потоков:

1. Парсер правильных скобочных последовательностей (падает, если последовательность неправильная, и не падает, если правильная).
2. Парсер целого числа, перед которым может быть знак `+` или `-`.

### Задание 4: Непростой парсер

Написать парсер списка списков чисел, разделённых запятой. Парсер должен иметь тип:
```haskell
listlistParser :: Parser Char [[Int]]
```
Все числа перечисленны через запятую. В начале каждого списка находится число --- длина списка. Таким образом можно понять, где заканчивается каждый список. То есть список

```haskell=
[ [1, 10], [5, -7, 2] ]
```

в строковом виде может быть записан следующим образом:

```haskell=
"2, 1,+10  , 3,5,-7, 2"
```

## Бонусное задание
Данное задание направлено на изучение монады `Cont`

```haskell
newtype Cont r a = Cont { runCont :: (a -> r) -> r }
```

Данная монада не имеет имеет простого аналога в императивных языках, но может быть полезна в некоторых случаях.

В данном задании от Вас требуется разобраться или реализовать самостоятельно инстансы `Functor`, `Applicative`, и `Monad` для `Cont`.

Затем, используя эту монаду реализовать небольшое подмножество системных вызовов операционной системы.

А именно, необходимо поддержать `read`, `write`, `exit`, `yield`, `fork`.

Должна иметься возможность написать следующий код:
```haskell
main' = do
  x <- readLine
  let str = "Hello, " ++ show x ++ "!" in
  writeLine str
  exit Success
```

Требуется также реализовать функцию `kernel`, которая будет интерпретировать данный код.

Информацию о монаде Cont можно найти [здесь](https://slides.com/fp-ctd/lecture-55#/29),
а больше информации, как реализовать то что требуется [здесь](https://www.dropbox.com/s/z1e1kxi32zl8kbd/DDToOS.pdf?dl=0).